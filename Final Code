#pragma config(Sensor, in1,	claw_pot,   	sensorPotentiometer)
#pragma config(Sensor, in2,	gyro,       	sensorGyro)
#pragma config(Sensor, dgtl1,  arm_encoder,	sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  drive_encoder,  sensorQuadEncoder)
#pragma config(Motor,  port1,       	LeftDriveB,	tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,       	RightDriveF,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,       	Claw,      	tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,       	FlipUpL,   	tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,       	MobileGoal,	tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,       	LeftDriveF,	tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,       	FlipUpR,   	tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,       	LeftArms,  	tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,       	RightArms, 	tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,      	RightDriveB,   tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard           	!!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/*---------------------------------------------------------------------------*/
/*                      	Pre-Autonomous Functions                     	*/
/*                                                                       	*/
/*  You may want to perform some actions before the competition starts.  	*/
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This   	*/
/*  function is only called once after the cortex has been powered on and	*/
/*  not every time that the robot is disabled.                           	*/
/*---------------------------------------------------------------------------*/

int claw_height;
int cone_counter;

void Arm()
{
	claw_height = 500 + (cone_counter * 200);
	Arm_Height(claw_height);
}

void Drive (int speed)
{
	motor[LeftDriveF] = speed;
	motor[LeftDriveB] = speed;
	motor[RightDriveF] = speed;
	motor[RightDriveB] = speed;
}


void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/*---------------------------------------------------------------------------*/
/*                                                                       	*/
/*                          	Autonomous Task                          	*/
/*                                                                       	*/
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                   	*/
/*                                                                       	*/
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous() //this is for backup and will probably not work. if it does then no pid
{
	Drive(100); //move forward 3 seconds
	wait1Msec(500);

	motor[MobileGoal] = 127; //pick up mobile goal
	wait1Msec(1500);

	Drive(0);
	wait1Msec(500);

	//Drive(-100); //drive backwards for 4 seconds
	//wait1Msec(3000);

	//motor[LeftDriveF] = 100; //turn bot in 1.5 seconds
	//motor[LeftDriveB] = 100;
	//motor[RightDriveF] = -100;
	//motor[RightDriveB] = -100;
	//wait1Msec(1500);

	//Drive(-100); // move bot backward for 1 second
	//wait1Msec(1000);

	//motor[LeftDriveF] = 100;//turn bot again for two seconds
	//motor[LeftDriveB] = 100;
	//motor[RightDriveF] = -100;
	//motor[RightDriveB] = -100;
	//wait1Msec(2000);

	//Drive(100);//move bot forwards for 1.5 seconds
	//wait1Msec(1500);

	//motor[MobileGoal] = -127; //drop mobile goal
	//wait1Msec(2000);
}


/*---------------------------------------------------------------------------*/
/*                                                                       	*/
/*                          	User Control Task                        	*/
/*                                                                       	*/
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                   	*/
/*                                                                       	*/
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
	int x_axis; //make these integers
	int y_axis;
	int lift;
	int claw_;
	int flip_up;
	int mobile_goal;

	float a_value = 0.000062;
	float multiplier = 1;

	while(true)
	{
		x_axis = (a_value * (vexRT[Ch1]* vexRT[Ch1]* vexRT[Ch1])); //acceleration curve, aka cubic drive
		y_axis = (a_value * (vexRT[Ch2]* vexRT[Ch2]* vexRT[Ch2]));
		lift  = vexRT[Ch3];

		if(vexRT[Btn5U] == 1) // if button 5u pressed, make claw go at 63 power
		{
			claw_ = 63;
		}
		else if(vexRT[Btn6U] == 1)// if button 5d pressed, make claw go at -63 power
		{
			claw_ = -63;
		}
		else //otherwise dont do anything
		{
			claw_ = 0;
		}



		if (vexRT[Btn8D] == 1) // if button 8u pressed, make mobile goal go at 127 power
		{
			mobile_goal = 127;
		}
		else if (vexRT[Btn8U] == 1)// if button 8d pressed, make mobile goal go at -127 power
		{
			mobile_goal = -127;
		}
		else
		{
			mobile_goal = 0; //otherwise dont do anything
		}




		if (vexRT[Btn7U] == 1) // if button 7u pressed, make flip up go at 63 power
		{
			flip_up = 63;
		}
		else if (vexRT[Btn7D] == 1) // if button 7d pressed, make flip up go at -63 power
		{
			flip_up = -63;
		}
		else
		{
			flip_up = 0; //otherwise dont do anything
		}


		if(vexRT[Btn5D] == 1) //if button 6u is held down, everything goes at 1/3 of the speed
		{
			multiplier = 0.3;
		}
		else
		{
			multiplier = 1; //otherwise its still at normal speed
		}


		if(vexRT[Btn6D] == 1) // macro #1, this is for gripping cone, raising arms, bringing flip up backwards,and lowering arms */
		{
			motor[Claw] = -63; //power claw for 1 sec
			wait1Msec(200);
			motor[RightArms] = 100; //raise arms and bring flip up backwards simultaneously for 1.2 seconds
			motor[LeftArms] = 100;
			motor[FlipUpL] = -127;
			motor[FlipUpR] = -127;
			wait1Msec(800);
			motor[Claw] = 0;	//make claw, flip up, and arms zero, so they dont continue spinning (for 0.2 sec)
			motor[RightArms] = 0;
			motor[LeftArms] = 0;
			motor[FlipUpL] = 0;
			motor[FlipUpR] = 0;
			wait1Msec(200);
			motor[RightArms] = -127; //lower arms for 1 sec
			motor[LeftArms] = -127;
			wait1Msec(1000);
			motor[RightArms] = 0; //make arms zero so they dont continue going down (for 0.2 sec)
			motor[LeftArms] = 0;
			wait1Msec(200);

			cone_counter ++;
		}

		if(vexRT[Btn8L] == 1) // macro #2, this is for releasing cone, raising arms, bringing flip up forwards,and lowering arms
		{
			motor[Claw] = -63; //release claw for 1 sec
			wait1Msec(1000);
			motor[RightArms] = 127; //raise arms and bring flip up forwards simultaneously for 1.2 seconds
			motor[LeftArms] = 127;
			motor[FlipUpL] = 127;
			motor[FlipUpR] = 127;
			wait1Msec(1200);
			motor[Claw] = 0;	//make claw,flip up, and arms zero so they dont continue spinning (for 0.2 sec)
			motor[RightArms] = 0;
			motor[LeftArms] = 0;
			motor[FlipUpL] = 0;
			motor[FlipUpR] = 0;
			wait1Msec(200);
			motor[RightArms] = -127; //lower arms for 1 sec
			motor[LeftArms] = -127;
			wait1Msec(1000);
			motor[RightArms] = 0; //make arms zero so they dont continue going down (for 0.2 sec)
			motor[LeftArms] = 0;
			wait1Msec(200);

			cone_counter++;
			
		}


		motor[LeftDriveF] = (y_axis + x_axis) *multiplier;
		motor[LeftDriveB] = (y_axis + x_axis) *multiplier;
		motor[RightDriveF] = (y_axis - x_axis) *multiplier;
		motor[RightDriveB] = (y_axis - x_axis) *multiplier;
		motor[RightArms] = lift;
		motor[LeftArms] = lift;
		motor[Claw] = claw_;
		motor[FlipUpL] = flip_up;
		motor[FlipUpR] = flip_up;
		motor[MobileGoal] = mobile_goal;

	}
}


